# Kaniko Build Task
# This task builds and pushes container images using Kaniko
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: kaniko-build
  namespace: pipelines-as-code
  labels:
    app.kubernetes.io/name: kaniko-build
    app.kubernetes.io/version: "1.0.0"
  annotations:
    tekton.dev/pipelines.minVersion: "0.38.0"
    tekton.dev/categories: Image Build
    tekton.dev/tags: "image-build,kaniko"
    tekton.dev/displayName: "Kaniko Build"
    tekton.dev/platforms: "linux/amd64"
spec:
  description: |
    This task builds a container image using Kaniko and pushes it to a registry.
    Kaniko builds container images from a Dockerfile inside a container or Kubernetes cluster.

  params:
    - name: IMAGE
      description: Name (reference) of the image to build
      type: string
    - name: DOCKERFILE
      description: Path to the Dockerfile to build
      type: string
      default: "./Dockerfile"
    - name: CONTEXT
      description: The build context used by Kaniko
      type: string
      default: "./"
    - name: EXTRA_ARGS
      description: Extra args to pass to kaniko
      type: string
      default: ""
    - name: BUILDER_IMAGE
      description: The image on which builds will run
      type: string
      default: "uhub.service.ucloud.cn/base-images/executor:v1.9.0"

  workspaces:
    - name: source
      description: Holds the context and Dockerfile
    - name: dockerconfig
      description: Includes a docker `config.json`
      optional: true
      mountPath: /kaniko/.docker

  results:
    - name: IMAGE_DIGEST
      description: Digest of the image just built
    - name: IMAGE_URL
      description: URL of the image just built
    - name: IMAGE_SIZE
      description: Size of the image just built

  steps:
    - name: build-and-push
      workingDir: $(workspaces.source.path)
      image: $(params.BUILDER_IMAGE)
      env:
        - name: DOCKER_CONFIG
          value: /kaniko/.docker
      script: |
        #!/busybox/sh
        set -e

        # Log build start
        echo "Starting Kaniko build..."
        echo "Image: $(params.IMAGE)"
        echo "Dockerfile: $(params.DOCKERFILE)"
        echo "Context: $(params.CONTEXT)"

        # Execute kaniko build
        /kaniko/executor \
          --dockerfile=$(params.DOCKERFILE) \
          --context=$(workspaces.source.path)/$(params.CONTEXT) \
          --destination=$(params.IMAGE) \
          --digest-file=$(results.IMAGE_DIGEST.path) \
          --cache=true \
          --cache-dir=/cache \
          --compressed-caching=false \
          --snapshot-mode=redo \
          --use-new-run \
          $(params.EXTRA_ARGS) 2>&1 | tee /tmp/kaniko.log

        # Extract image digest and size from logs
        if [ -f $(results.IMAGE_DIGEST.path) ]; then
          IMAGE_DIGEST=$(cat $(results.IMAGE_DIGEST.path))
        else
          IMAGE_DIGEST=$(grep "digest:" /tmp/kaniko.log | tail -1 | sed 's/.*digest: //' | tr -d '\r\n')
        fi

        if grep -q "Pushed" /tmp/kaniko.log; then
          IMAGE_SIZE=$(grep "Pushed" /tmp/kaniko.log | grep -o '[0-9.]*[KMGT]B' | tail -1 || echo "unknown")
        else
          IMAGE_SIZE="unknown"
        fi

        # Save results
        echo "${IMAGE_DIGEST}" > $(results.IMAGE_DIGEST.path)
        echo "$(params.IMAGE)" > $(results.IMAGE_URL.path)
        echo "${IMAGE_SIZE}" > $(results.IMAGE_SIZE.path)

        echo "Build completed successfully"
        echo "Image: $(params.IMAGE)"
        echo "Digest: ${IMAGE_DIGEST}"
        echo "Size: ${IMAGE_SIZE}"
      securityContext:
        runAsUser: 0
        runAsGroup: 0
      resources:
        requests:
          memory: "512Mi"
          cpu: "250m"
        limits:
          memory: "2Gi"
          cpu: "1000m"
      volumeMounts:
        - name: kaniko-cache
          mountPath: /cache

  volumes:
    - name: kaniko-cache
      emptyDir:
        sizeLimit: 2Gi
